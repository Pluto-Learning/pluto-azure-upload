# Operating Systems: Chapter 9 & 10 Summary

## Table of Contents
1. [Types of Resources](#types-of-resources)
2. [Deadlocks](#deadlocks)
3. [Deadlock Modeling](#deadlock-modeling)
4. [Deadlock Detection and Recovery](#deadlock-detection-and-recovery)
5. [Memory Management](#memory-management)
6. [Heap Fragmentation and Space](#heap-fragmentation-and-space)

---

## Types of Resources
### Preemptable and Nonpreemptable Resources
- **Preemptable**: Can be taken away from the process owning it without causing issues.
  - Example: Memory
- **Nonpreemptable**: Cannot be taken away without causing failure.
  - Example: Burning a Blu-ray

### Context-Dependent Resources
- PC memory is preemptable due to page swapping.
- Smartphones without swapping can't avoid deadlocks by swapping out memory.

---

## Deadlocks
### General Information
- Deadlocks generally involve nonpreemptable resources.
- **Sequence of Events to Use a Resource**:
  1. Request the resource
  2. Use the resource
  3. Release the resource

### Conditions for Deadlock
- **Mutual Exclusion**: Resource is either assigned to one process or is available.
- **Hold-and-Wait**: Processes holding resources can request new ones.
- **No-Preemption**: Resources can't be forcibly taken away.
- **Circular Wait**: Circular list of processes, each waiting for a resource held by the next.

> Note: All four conditions must be present for a deadlock to occur.

---

## Deadlock Modeling
### Directed Graphs
- Processes are shown as circles, and resources as squares.
- Strategies for dealing with deadlocks:
  1. Ignore the problem
  2. Detection and recovery
  3. Dynamic avoidance
  4. Prevention

---

## Deadlock Detection and Recovery
### Simple Case
- Construct a resource graph to detect cycles for deadlocks.

### Multiple Resources
- Use matrix-based algorithms for systems with multiple copies of resources.
- **Data Structures Needed**:
  - `E`: Existing resource vector
  - `A`: Available resource vector
  - `C`: Current allocation matrix
  - `R`: Request matrix

#### Algorithm Steps
1. Look for an unmarked process, `Pi`, where `R` is <= `A`.
2. If found, add `C` to `A`, mark the process, and repeat step 1.

---

## Memory Management
### Address Spaces
- Address space is the set of all addresses that a process can use.
- Each process has an independent address space.

### Physical vs. Logical Addresses
- **Logical Addresses**: Addresses generated by the CPU during execution.
- **Physical Addresses**: Addresses used to reference physical memory.

---

## Heap Fragmentation and Space
### Heap Fragmentation
- Fragmentation can prevent allocation of larger chunks of memory.

### Compaction
- OS can reorganize fragmented space to make it contiguous.

### Allocation Strategies
- **First / Next Fit**: Allocates the first or next fitting chunk.
- **Best Fit**: Allocates the best-fitting chunk.

# Operating Systems: Chapter 10 Continued

## Table of Contents
1. [Heap Allocation Strategies](#heap-allocation-strategies)
2. [Managing Free Memory](#managing-free-memory)
3. [Paging](#paging)
4. [Effective Access Time](#effective-access-time)
5. [Context Switches](#context-switches)
6. [Demand Paging](#demand-paging)
7. [Working Set](#working-set)
8. [Page Replacement](#page-replacement)

---

## Heap Allocation Strategies
### Worst Fit
- Allocates the largest free chunk.
  
### New Chunk Allocated
- New chunks can be allocated based on the strategy used (Best Fit, Worst Fit, etc.).

---

## Managing Free Memory
### Methods to Track Memory Usage
- **Bit Maps**
- **Free Lists**

### Linux Memory Allocators
- Buddy and slab allocators are used in Linux.

### Bitmap
- Memory is divided into allocation units.
- Each unit corresponds to a bit in the bitmap.

#### Problems with Bitmap
- Searching for `k` consecutive 0’s can be time-consuming.

### Linked List
- List of allocated and free memory segments.

---

## Paging
### Basics
- Logical address space can be noncontiguous.
- Physical memory is divided into fixed-sized blocks called frames.
- Logical memory is divided into blocks of the same size called pages.

### Address Translation Scheme
- Address generated by CPU is divided into:
  - **Page Number (p)**: Used as an index into a page table.
  - **Page Offset (d)**: Combined with base address to define the physical memory address.

---

## Effective Access Time
### Calculations
- EAT (Effective Access Time) can be calculated based on hit ratio and memory cycle time.

#### Example
- Associative Lookup = 5 ns
- Memory cycle time = 100 ns
- Hit ratio = 80%
- EAT = 124 ns

---

## Context Switches
### TLB (Translation Lookaside Buffer)
- TLB must be flushed during a context switch.
- Threads vs. Processes

---

## Demand Paging
### Basics
- Allows execution of processes that are not completely in memory.
- Reduces I/O and memory needs.

### Working Set
- Set of pages a process is currently using.
- Measured over a sliding window.

### Page Replacement
- Removing a page that may not be needed anymore.

#### Basic Steps
1. Find the location of the desired page on disk.
2. Find a free frame or use a page replacement algorithm to select a victim frame.
3. Update the page and frame tables.
4. Restart the process.

---

## Page Replacement Algorithms
- Aim for the lowest page-fault rate.
- Algorithms are evaluated based on the number of page faults they produce on a specific reference string.

# Operating Systems: Page Replacement Algorithms

## Table of Contents
1. [First In, First Out (FIFO)](#first-in-first-out-fifo)
2. [Bélády's Anomaly](#béládys-anomaly)
3. [Optimal Algorithm](#optimal-algorithm)
4. [Least Recently Used (LRU)](#least-recently-used-lru)
5. [Reference Counter Variation](#reference-counter-variation)
6. [Second Chance Algorithm](#second-chance-algorithm)
7. [Not Recently Used](#not-recently-used)
8. [Counting Algorithms](#counting-algorithms)
9. [Demand Paging and Thrashing](#demand-paging-and-thrashing)

---

## First In, First Out (FIFO)

- **Concept**: Eject the oldest page.
- **Pros**:
  - Very low overhead
  - Easy to implement
- **Cons**:
  - Poor performance and erratic behavior
  - Can end up evicting the most frequently used page
  - Subject to Bélády’s anomaly

### Example: FIFO Algorithm

- **Reference String**: `1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5`
- **3 Frames**: 9 page faults
- **4 Frames**: 10 page faults (Bélády’s Anomaly)

---

## Bélády's Anomaly

- **Definition**: Increasing the number of page frames results in an increase in the number of page faults for a given memory access pattern.

### Example: Bélády's Anomaly

- **3 Page Frames**: 9 faults (red)
- **4 Page Frames**: 10 faults (red)

---

## Optimal Algorithm

- **Concept**: Replace page that will not be used for the longest period of time.
- **Pros**: Provides a best-case for measuring algorithm performance.
- **Cons**: Unrealizable, requires future knowledge.

### Example: Optimal Algorithm

- **4 Frames**: 6 page faults

---

## Least Recently Used (LRU)

- **Concept**: Eject the page that has not been used for the longest time.
- **Pros**: Can approximate, similar to NRU.
- **Cons**: Impractical to track, need hardware assistance.

### Example: LRU Algorithm

- **Reference String**: `1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5`

---

## Reference Counter Variation

- **Also Known As**: Aging
- **Concept**: As reference bits are cleared, shift into a counter—one for each page.

---

## Second Chance Algorithm

- **Concept**: Sorted in reference time order. When page referenced, set R bit.

---

## Not Recently Used

- **Concept**: Each page has two status bits, R (read) and M (modified).
- **Categories**:
  - Class 0: not referenced, not modified
  - Class 1: not referenced, modified
  - Class 2: referenced, not modified
  - Class 3: referenced, modified

---

## Counting Algorithms

- **Concept**: Keep a counter of the number of references made to each page.
- **Types**:
  - LFU Algorithm: replaces page with smallest count
  - MFU Algorithm: replaces page with largest count

---

## Demand Paging and Thrashing

- **Why does demand paging work?**: Locality model
- **Why does thrashing occur?**: Σ size of locality > total memory size

---

*Note: This document is based on slides by Silberschatz, Galvin and Gagne ©2009.*

# Operating Systems Course Notes

## Table of Contents
1. [Indexed Allocation – Mapping](#indexed-allocation--mapping)
2. [Recovery](#recovery)
3. [MS-DOS File System](#ms-dos-file-system)
4. [Structure of Ext2 Filesystem](#structure-of-ext2-filesystem)
5. [CD-ROM File System](#cd-rom-file-system)

---

## Indexed Allocation – Mapping

### Two-level index
- **Maximum file size**: \(512^3\)
- **LA / (512 x 512)**
- **Q1**: Displacement into outer-index
- **R1**: Used as follows \(R1 / 512\)
- **Q2**: Displacement into block of index table
- **R2**: Displacement into block of file

### Components
- Outer-index
- Index table file

---

## Recovery

### Consistency Checking
- Compares data in directory structure with data blocks on disk
- Tries to fix inconsistencies

### Backup and Restore
- Use system programs to back up data from disk to another storage device
- Types of backups: Full vs. Incremental backups

---

## MS-DOS File System

### General Information
- First file system for IBM PCs
- Main file system up through Windows 98 and Windows ME
- Still supported in newer Windows versions
- More devices use FAT-32 than NTFS

### File and Directory Structure
- File names max size is 8+3
- Attributes for read/write/hidden/archive/system
- Time stores creation time
- Date stores the date in days

### Limitations
- Size is stored as 32-bit number
- Theoretical max file size of 4 GB
- Other limitations limit this to 2 GB

### FAT Versions
- FAT-12, FAT-16, FAT-32
- FAT-32 misnomer: Only 28 bits are actually used
- exFAT: Introduced for large removable devices

---

## Structure of Ext2 Filesystem

### The SuperBlock
- Contains information such as the total number of blocks on disk, the size of a block, etc.

#### Part of SuperBlock Structure
```c
struct ext2_super_block {
  __u32 s_inodes_count;
  __u32 s_blocks_count;
  __u32 s_free_blocks_count;
  __u32 s_free_inodes_count;
  __u32 s_first_data_block;
  __u32 s_log_block_size;
  __u32 s_blocks_per_group;
  __u16 s_magic;
};
```

### Group Descriptors
- List of block-group descriptors
- Contains a descriptor for each block group on the disk

#### Group Descriptor Structure
```c
struct ext2_group_desc {
  __u32 bg_block_bitmap;
  __u32 bg_inode_bitmap;
  __u32 bg_inode_table;
  __u16 bg_free_blocks_count;
  __u16 bg_free_inodes_count;
  __u16 bg_used_dirs_count;
  __u16 bg_pad;
  __u32 bg_reserved[3];
};
```

### The Inode Table
- Contains everything the OS needs to know about a file
- Accessed very frequently

#### Inode Structure
```c
struct ext2_inode {
  __u16 i_mode;
  __u16 i_uid;
  __u32 i_size;
  __u32 i_atime;
  __u32 i_ctime;
  __u32 i_mtime;
  __u32 i_dtime;
  __u16 i_gid;
  __u16 i_links_count;
  __u32 i_blocks;
  __u32 i_flags;
  __u32 i_block[EXT2_N_BLOCKS];
};
```

---

## CD-ROM File System

- Simple since designed for write-once media
- No provision for tracking free blocks
